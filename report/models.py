import csv
import json
from io import StringIO
from django.db import models
from django.conf import settings
from django.utils import timezone
from django.core.serializers.json import DjangoJSONEncoder


class Report(models.Model):
    """Model to store and manage generated reports in the library system."""
    
    class ReportType(models.TextChoices):
        OVERDUE = 'overdue', 'Overdue Books'
        BORROWED = 'borrowed', 'Borrowed Books'
        FINES = 'fines', 'Fines Report'
        POPULAR_BOOKS = 'popular_books', 'Popular Books'
        ACTIVE_USERS = 'active_users', 'Active Users'
    
    report_type = models.CharField(
        max_length=50,
        choices=ReportType.choices,
        verbose_name='Report Type',
        help_text='Type of the generated report'
    )
    
    data = models.JSONField(
        verbose_name='Report Data',
        help_text='Structured data for the report',
        encoder=DjangoJSONEncoder
    )
    
    generated_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        verbose_name='Generated By',
        related_name='generated_reports',
        help_text='User who generated this report'
    )
    
    generated_at = models.DateTimeField(
        default=timezone.now,
        verbose_name='Generated At',
        help_text='When the report was generated'
    )
    
    is_active = models.BooleanField(
        default=True,
        verbose_name='Is Active',
        help_text='Whether this report is currently active or archived'
    )
    
    scheduled = models.BooleanField(
        default=False,
        verbose_name='Scheduled Report',
        help_text='Whether this report was generated by a scheduled task'
    )
    
    filters = models.JSONField(
        verbose_name='Report Filters',
        help_text='Filters used to generate this report',
        null=True,
        blank=True,
        encoder=DjangoJSONEncoder
    )
    
    description = models.TextField(
        blank=True,
        null=True,
        verbose_name='Description',
        help_text='Optional description of the report'
    )
    
    class Meta:
        verbose_name = 'Report'
        verbose_name_plural = 'Reports'
        ordering = ['-generated_at']
        indexes = [
            models.Index(fields=['report_type']),
            models.Index(fields=['generated_at']),
            models.Index(fields=['generated_by']),
            models.Index(fields=['is_active']),
            models.Index(fields=['scheduled']),
        ]
    
    def __str__(self):
        status = 'Active' if self.is_active else 'Archived'
        return f'{self.get_report_type_display()} - {self.generated_at.strftime("%Y-%m-%d")} ({status})'
    
    def export_to_csv(self):
        """Export report data to CSV format.
        
        Returns:
            StringIO: A file-like object containing the CSV data
            
        Raises:
            ValueError: If the data format is not suitable for CSV export
        """
        if not isinstance(self.data, (list, dict)):
            raise ValueError("Report data must be a list or dictionary for CSV export")
            
        output = StringIO()
        writer = csv.writer(output)
        
        if isinstance(self.data, list) and self.data:
            # Handle list of dictionaries
            if all(isinstance(item, dict) for item in self.data):
                # Write headers
                headers = list(self.data[0].keys())
                writer.writerow(headers)
                
                # Write data rows
                for item in self.data:
                    writer.writerow([str(item.get(header, '')) for header in headers])
            else:
                # Handle list of values
                writer.writerow(['Value'])
                for item in self.data:
                    writer.writerow([str(item)])
        elif isinstance(self.data, dict):
            # Handle dictionary
            writer.writerow(['Key', 'Value'])
            for key, value in self.data.items():
                writer.writerow([key, str(value)])
        
        output.seek(0)
        return output
    
    def export_to_json(self, indent=2):
        """Export report data to JSON format.
        
        Args:
            indent (int, optional): Number of spaces for indentation. Defaults to 2.
            
        Returns:
            str: JSON formatted string of the report data
        """
        return json.dumps(self.data, indent=indent, cls=DjangoJSONEncoder)
    
    def archive(self):
        """Mark the report as archived."""
        self.is_active = False
        self.save(update_fields=['is_active', 'modified'])
    
    def restore(self):
        """Mark the report as active."""
        self.is_active = True
        self.save(update_fields=['is_active', 'modified'])
    
    def save(self, *args, **kwargs):
        """Override save to update modified timestamp and create archive if needed."""
        is_new = self._state.adding
        if not is_new:
            # Create archive before updating
            ReportArchive.create_from_report(self)
        self.modified = timezone.now()
        super().save(*args, **kwargs)


class ReportTemplate(models.Model):
    """Model to define report templates and layouts."""
    
    class TemplateFormat(models.TextChoices):
        HTML = 'html', 'HTML'
        PDF = 'pdf', 'PDF'
        CSV = 'csv', 'CSV'
        EXCEL = 'xlsx', 'Excel'
    
    name = models.CharField(
        max_length=100,
        verbose_name='Template Name',
        help_text='Name of the template'
    )
    
    description = models.TextField(
        blank=True,
        verbose_name='Description',
        help_text='Template description and usage notes'
    )
    
    format = models.CharField(
        max_length=10,
        choices=TemplateFormat.choices,
        default=TemplateFormat.HTML,
        verbose_name='Output Format'
    )
    
    template_file = models.FileField(
        upload_to='report_templates/',
        null=True,
        blank=True,
        verbose_name='Template File',
        help_text='Upload template file if needed'
    )
    
    is_active = models.BooleanField(
        default=True,
        verbose_name='Is Active',
        help_text='Whether this template is active for use'
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        verbose_name = 'Report Template'
        verbose_name_plural = 'Report Templates'
        ordering = ['name']
    
    def __str__(self):
        return f"{self.name} ({self.get_format_display()})"


class ReportSchedule(models.Model):
    """Model to schedule recurring report generation."""
    
    class ScheduleFrequency(models.TextChoices):
        DAILY = 'daily', 'Daily'
        WEEKLY = 'weekly', 'Weekly'
        MONTHLY = 'monthly', 'Monthly'
        QUARTERLY = 'quarterly', 'Quarterly'
        YEARLY = 'yearly', 'Yearly'
    
    name = models.CharField(
        max_length=100,
        verbose_name='Schedule Name',
        help_text='Name for this schedule'
    )
    
    report_type = models.CharField(
        max_length=50,
        choices=Report.ReportType.choices,
        verbose_name='Report Type'
    )
    
    frequency = models.CharField(
        max_length=20,
        choices=ScheduleFrequency.choices,
        verbose_name='Frequency'
    )
    
    day_of_week = models.PositiveSmallIntegerField(
        null=True,
        blank=True,
        choices=[(i, day) for i, day in enumerate(['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'])],
        verbose_name='Day of Week',
        help_text='Required for weekly frequency'
    )
    
    day_of_month = models.PositiveSmallIntegerField(
        null=True,
        blank=True,
        verbose_name='Day of Month',
        help_text='Required for monthly/quarterly frequency (1-31)'
    )
    
    time_of_day = models.TimeField(
        default='09:00',
        verbose_name='Time of Day',
        help_text='When to generate the report'
    )
    
    is_active = models.BooleanField(
        default=True,
        verbose_name='Is Active',
        help_text='Whether this schedule is active'
    )
    
    last_run = models.DateTimeField(
        null=True,
        blank=True,
        verbose_name='Last Run',
        help_text='When this schedule was last executed'
    )
    
    next_run = models.DateTimeField(
        null=True,
        blank=True,
        verbose_name='Next Run',
        help_text='When this schedule will run next'
    )
    
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        related_name='scheduled_reports'
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        verbose_name = 'Report Schedule'
        verbose_name_plural = 'Report Schedules'
        ordering = ['name']
    
    def __str__(self):
        return f"{self.name} ({self.get_frequency_display()})"


class ReportRecipient(models.Model):
    """Model to manage report recipients."""
    
    class RecipientType(models.TextChoices):
        EMAIL = 'email', 'Email'
        USER = 'user', 'System User'
        GROUP = 'group', 'User Group'
    
    name = models.CharField(
        max_length=100,
        verbose_name='Recipient Name',
        help_text='Name for this recipient entry'
    )
    
    recipient_type = models.CharField(
        max_length=20,
        choices=RecipientType.choices,
        verbose_name='Recipient Type'
    )
    
    email = models.EmailField(
        blank=True,
        null=True,
        verbose_name='Email Address',
        help_text='Required for email recipients'
    )
    
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name='report_recipients'
    )
    
    is_active = models.BooleanField(
        default=True,
        verbose_name='Is Active',
        help_text='Whether this recipient should receive reports'
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        verbose_name = 'Report Recipient'
        verbose_name_plural = 'Report Recipients'
        ordering = ['name']
    
    def __str__(self):
        return self.name


class ReportParameter(models.Model):
    """Model to store parameter configurations for reports."""
    
    class ParameterType(models.TextChoices):
        STRING = 'string', 'String'
        NUMBER = 'number', 'Number'
        DATE = 'date', 'Date'
        BOOLEAN = 'boolean', 'Boolean'
        CHOICE = 'choice', 'Choice'
    
    name = models.CharField(
        max_length=100,
        verbose_name='Parameter Name',
        help_text='Internal name for the parameter'
    )
    
    label = models.CharField(
        max_length=100,
        verbose_name='Display Label',
        help_text='User-friendly label for the parameter'
    )
    
    param_type = models.CharField(
        max_length=20,
        choices=ParameterType.choices,
        verbose_name='Parameter Type'
    )
    
    default_value = models.TextField(
        blank=True,
        null=True,
        verbose_name='Default Value',
        help_text='Default value for the parameter'
    )
    
    is_required = models.BooleanField(
        default=False,
        verbose_name='Is Required',
        help_text='Whether this parameter is required'
    )
    
    choices = models.TextField(
        blank=True,
        null=True,
        verbose_name='Choices',
        help_text='Comma-separated list of choices for CHOICE type parameters'
    )
    
    class Meta:
        verbose_name = 'Report Parameter'
        verbose_name_plural = 'Report Parameters'
        ordering = ['name']
    
    def __str__(self):
        return f"{self.label} ({self.get_param_type_display()})"
    
    def get_choices_list(self):
        """Get parameter choices as a list of tuples."""
        if not self.choices:
            return []
        return [(choice.strip(), choice.strip()) for choice in self.choices.split(',')]


class ReportArchive(models.Model):
    """Model to store historical snapshots of reports."""
    
    report = models.ForeignKey(
        Report,
        on_delete=models.CASCADE,
        related_name='archives',
        verbose_name='Original Report',
        help_text='The report this archive belongs to'
    )
    
    data_snapshot = models.JSONField(
        verbose_name='Report Data Snapshot',
        help_text='Snapshot of the report data at the time of archiving',
        encoder=DjangoJSONEncoder
    )
    
    archived_at = models.DateTimeField(
        auto_now_add=True,
        verbose_name='Archived At',
        help_text='When this archive was created'
    )
    
    archived_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        verbose_name='Archived By',
        help_text='User who created this archive',
        related_name='archived_reports'
    )
    
    class Meta:
        verbose_name = 'Report Archive'
        verbose_name_plural = 'Report Archives'
        ordering = ['-archived_at']
        indexes = [
            models.Index(fields=['report']),
            models.Index(fields=['archived_at']),
        ]
        get_latest_by = 'archived_at'
    
    def __str__(self):
        return f'{self.report.get_report_type_display()} - {self.archived_at.strftime("%Y-%m-%d %H:%M")}'
    
    @classmethod
    def create_from_report(cls, report, user=None):
        """Create an archive from a report instance.
        
        Args:
            report: The Report instance to archive
            user: The user creating the archive (optional)
            
        Returns:
            ReportArchive: The created archive instance
        """
        return cls.objects.create(
            report=report,
            data_snapshot=report.data,
            archived_by=user or report.generated_by
        )
    
    def get_absolute_url(self):
        """Get URL to view this archive."""
        from django.urls import reverse
        return reverse('reports:archive-detail', kwargs={'pk': self.pk})


class ReportCategory(models.Model):
    """Model for categorizing reports."""
    
    name = models.CharField(
        max_length=100,
        unique=True,
        verbose_name='Category Name',
        help_text='Name of the category'
    )
    
    description = models.TextField(
        blank=True,
        verbose_name='Description',
        help_text='Description of the category'
    )
    
    parent = models.ForeignKey(
        'self',
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name='subcategories',
        verbose_name='Parent Category'
    )
    
    icon = models.CharField(
        max_length=50,
        blank=True,
        verbose_name='Icon',
        help_text='Icon class (e.g., fa-chart-bar)'
    )
    
    is_active = models.BooleanField(
        default=True,
        verbose_name='Is Active'
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        verbose_name = 'Report Category'
        verbose_name_plural = 'Report Categories'
        ordering = ['name']
    
    def __str__(self):
        return self.name
    
    def get_full_path(self):
        """Get full category path including parent categories."""
        if self.parent:
            return f"{self.parent.get_full_path()} > {self.name}"
        return self.name


class ReportFavorite(models.Model):
    """Model for users to bookmark frequently used reports."""
    
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='favorite_reports'
    )
    
    report = models.ForeignKey(
        Report,
        on_delete=models.CASCADE,
        related_name='favorited_by'
    )
    
    notes = models.TextField(
        blank=True,
        verbose_name='Notes',
        help_text='Personal notes about this favorite'
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        verbose_name = 'Favorite Report'
        verbose_name_plural = 'Favorite Reports'
        unique_together = ('user', 'report')
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.user.username}'s favorite: {self.report}"


class ReportSubscription(models.Model):
    """Model for users to subscribe to report updates."""
    
    class NotificationFrequency(models.TextChoices):
        IMMEDIATE = 'immediate', 'Immediate'
        DAILY = 'daily', 'Daily Digest'
        WEEKLY = 'weekly', 'Weekly Digest'
    
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='report_subscriptions'
    )
    
    report = models.ForeignKey(
        Report,
        on_delete=models.CASCADE,
        related_name='subscriptions'
    )
    
    frequency = models.CharField(
        max_length=20,
        choices=NotificationFrequency.choices,
        default=NotificationFrequency.IMMEDIATE,
        verbose_name='Notification Frequency'
    )
    
    is_active = models.BooleanField(
        default=True,
        verbose_name='Is Active'
    )
    
    last_notified = models.DateTimeField(
        null=True,
        blank=True,
        verbose_name='Last Notified'
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        verbose_name = 'Report Subscription'
        verbose_name_plural = 'Report Subscriptions'
        unique_together = ('user', 'report')
    
    def __str__(self):
        return f"{self.user.username} - {self.report} ({self.get_frequency_display()})"


class ReportExport(models.Model):
    """Model to track report exports and downloads."""
    
    class ExportFormat(models.TextChoices):
        PDF = 'pdf', 'PDF'
        EXCEL = 'xlsx', 'Excel'
        CSV = 'csv', 'CSV'
        JSON = 'json', 'JSON'
    
    report = models.ForeignKey(
        Report,
        on_delete=models.CASCADE,
        related_name='exports'
    )
    
    exported_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        related_name='report_exports'
    )
    
    export_format = models.CharField(
        max_length=10,
        choices=ExportFormat.choices,
        verbose_name='Export Format'
    )
    
    file_path = models.FileField(
        upload_to='report_exports/%Y/%m/%d',
        verbose_name='Exported File',
        null=True,
        blank=True
    )
    
    file_size = models.PositiveIntegerField(
        null=True,
        blank=True,
        verbose_name='File Size (bytes)'
    )
    
    download_count = models.PositiveIntegerField(
        default=0,
        verbose_name='Download Count'
    )
    
    expires_at = models.DateTimeField(
        null=True,
        blank=True,
        verbose_name='Expires At',
        help_text='When this export will be automatically deleted'
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        verbose_name = 'Report Export'
        verbose_name_plural = 'Report Exports'
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.report} - {self.get_export_format_display()} ({self.created_at})"
    
    def increment_download_count(self):
        """Increment the download counter."""
        self.download_count += 1
        self.save(update_fields=['download_count'])


class ReportComment(models.Model):
    """Model for adding comments and discussions on reports."""
    
    report = models.ForeignKey(
        Report,
        on_delete=models.CASCADE,
        related_name='comments'
    )
    
    author = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        related_name='report_comments'
    )
    
    parent = models.ForeignKey(
        'self',
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name='replies'
    )
    
    content = models.TextField(
        verbose_name='Comment',
        help_text='Enter your comment here'
    )
    
    is_internal = models.BooleanField(
        default=False,
        verbose_name='Internal Note',
        help_text='If checked, this comment will only be visible to staff members'
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        verbose_name = 'Report Comment'
        verbose_name_plural = 'Report Comments'
        ordering = ['created_at']
    
    def __str__(self):
        return f"Comment by {self.author} on {self.report}"
    
    @property
    def is_edited(self):
        """Check if the comment has been edited."""
        return self.updated_at > self.created_at + timedelta(seconds=60)
    
    def get_reply_count(self):
        """Get total number of replies to this comment."""
        return self.replies.count()
